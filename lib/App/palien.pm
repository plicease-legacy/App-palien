package App::palien;

use strict;
use warnings;
use Getopt::Long qw( GetOptions );
use Pod::Usage qw( pod2usage );
use Path::Class qw( file dir );

# ABSTRACT: Command line interface to Alien::Base
# VERSION

=head1 DESCRIPTION

This module provides the machinery for the command line
program L<palien>.

=head1 SEE ALSO

L<palien>

=cut

sub _version ($)
{
  my($alien) = @_;
  my $class = ref $alien;
  eval qq{ \$$class\::VERSION };
}

sub _modversion ($)
{
  my($alien) = @_;
  return $alien->version if $alien->can('version');
  return 'unknown' unless $alien->can('config');
  my $ver = $alien->config('version');
  chomp $ver;
  $ver;
}

sub _cflags ($)
{
  my($alien) = @_;
  scalar $alien->cflags;
}

sub _libs ($)
{
  my($alien) = @_;
  scalar $alien->libs;
}

sub main
{
  local(undef, @ARGV) = @_;
  
  my $cflags;
  my $libs;
  my $list;
  my $dll;
  my $modversion;
  my $detail;
  my $status = 0;
  
  GetOptions(
    "cflags"     =>   \$cflags,
    "libs"       =>   \$libs,
    "dll"        =>   \$dll,
    "modversion" =>   \$modversion,
    "detail|d"   =>   \$detail,
    "help|h"     =>   sub { pod2usage({ -verbose => 2}) },
    "version"    =>   sub { print "App::palien version " . ($App::palien::VERSION || 'dev') . "\n"; exit 1; },
  ) || pod2usage(1);

  unless(@ARGV)
  {
    my %mods;
    foreach my $inc (@INC)
    {
      my $dir = dir( $inc, 'Alien' );
      next unless -d $dir;
      foreach my $pm (grep /\.pm$/, map { $_->basename } grep { ! $_->is_dir } $dir->children)
      {
        $pm =~ s/\.pm$//;
        next if $pm =~ /^(Base|Packages)$/;
        $mods{"Alien::$pm"} = 1;
      }

      my $share_root = dir( $inc, qw( auto share dist ) );
      next unless -d $share_root;
      foreach my $share ($share_root->children)
      {
        my $readme = $share->file('README');
        next unless (-r $readme) && ($readme->slurp =~ /This README file is autogenerated by Alien::Base/);
        my $module = $share->basename;
        $module =~ s/-/::/g;
        $mods{$module} = 1;
      }

    }
    
    @ARGV = sort keys %mods;
  }

  foreach my $module (@ARGV)
  {
    my $alien;
  
    if($module =~ /::/)
    {
      $alien = eval qq{ require $module; $module->new };
      if($@)
      {
        warn "unable to load $module: $@";
        $status = 2;
        next;
      }
    }
    else
    {
      $alien = find($module);
      next unless $alien;
    }
    
    if($detail)
    {
      my $class = ref $alien;
      printf "=============================================\n";
      printf "class:      %s\n", ref $alien;
      printf "version:    %s\n", _version $alien;
      printf "modversion: %s\n", _modversion $alien;
      printf "dist:       %s\n", $alien->dist_dir if eval { $alien->dist_dir };
      printf "cflags:     %s\n", _cflags $alien;
      printf "libs:       %s\n", _libs $alien;
    }
    
    if($cflags)
    {
      print _cflags $alien, "\n";
    }
    
    if($libs)
    {
      print _libs $alien, "\n";
    }
    
    if($modversion)
    {
      print _modversion $alien, "\n";
    }
    
    if($dll)
    {
      print $_, "\n" for $alien->dynamic_libs;
    }
  }
  
  $status;
}

my $byname;

sub find
{
  my($q) = @_;

  unless($byname)
  {
    $byname->{libarchive} = 'Alien::Libarchive';
    $byname->{bz2}        = 'Alien::bz2';
    foreach my $inc (@INC)
    {
      my $share_root = dir( $inc, qw( auto share dist ) );
      next unless -d $share_root;
      foreach my $share ($share_root->children)
      {
        my $readme = $share->file('README');
        next unless (-r $readme) && ($readme->slurp =~ /This README file is autogenerated by Alien::Base/);
        my $module = $share->basename;
        $module =~ s/-/::/g;
        my $name = eval qq{ require $module\::ConfigData; $module\::ConfigData->config('name'); };
        $byname->{$name} = $module;
      }
    }
  }
  
  my $module = $byname->{$q};
  
  defined $module ? eval qq{ require $module; $module->new } || warn "unable to load $module: $@" && () : ();
}

1;
